@page
@model LiveChatTask.Pages.User.ChatModel
@{
    ViewData["Title"] = "Chat with Support";
    ViewData["BodyClass"] = "user-chat-page";
}

<link rel="stylesheet" href="~/css/user-chat.css" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<style>
    body {
        font-family: 'Inter', sans-serif;
        margin: 0;
    }
</style>

<div class="chat-container">
    <!-- Header -->
    <div class="chat-header">
        <div class="chat-header-left">
            <div>
                <h1>üí¨ Support Chat</h1>
                <div class="chat-subtitle">We're here to help you</div>
            </div>
        </div>
        <div class="chat-header-right">
            <div id="sessionTimer" class="session-timer" style="display: none;">
                <span class="timer-label">Session expires in:</span>
                <span id="timerMinutes" class="timer-value">--</span>
                <span class="timer-unit">minutes</span>
            </div>
            <form id="userLogoutForm" method="post" asp-page-handler="Logout">
                <button type="button" id="userLogoutBtn" class="header-btn">Logout</button>
            </form>
        </div>
    </div>

    <!-- Messages -->
    <div class="messages-wrapper" id="messagesWrapper">
        <div class="messages-list" id="messagesList">
            <div class="empty-chat-state">
                <div class="icon">üí¨</div>
                <h3>Start a Conversation</h3>
                <p>Send a message to connect with our support team. We typically respond within a few minutes.</p>
            </div>
        </div>
    </div>

    <!-- Expired session banner (hidden by default, shown when session expires) -->
    <div id="expiredSessionBanner" class="expired-session-banner d-none">
        <div class="expired-banner-content">
            <span class="expired-icon">‚è∞</span>
            <p id="expiredSessionBannerText" class="expired-text">Your chat session has expired.</p>
            <button type="button" id="startNewSessionBtn" class="start-new-session-btn">Start New Chat Session</button>
        </div>
    </div>

    <!-- Message Input -->
    <div class="message-input-area">
        <div class="input-container">
            <div id="filePreviewArea" class="file-preview-area d-none">
                <div class="file-preview">
                    <img id="filePreviewImage" src="" alt="Preview" class="d-none" />
                    <div class="file-preview-info">
                        <strong id="filePreviewName"></strong>
                        <small id="filePreviewSize"></small>
                    </div>
                    <button type="button" class="remove-file-btn" id="removeFileBtn">‚úï</button>
                </div>
            </div>
            
            <div class="input-wrapper">
                <label class="file-upload-label">
                    üìé
                    <input type="file" id="fileInput" accept="image/*,.pdf,.doc,.docx,.txt" />
                </label>
                
                <button id="voiceRecordBtn" class="voice-record-btn" type="button" title="Record voice message">üé§</button>
                <div id="voiceRecordingIndicator" class="voice-recording-indicator d-none">
                    <span class="recording-dot"></span>
                    <span id="recordingTimer">00:00</span>
                    <button id="voiceStopBtn" type="button" class="voice-stop-btn">Stop</button>
                    <button id="voiceCancelBtn" type="button" class="voice-cancel-btn">Cancel</button>
                </div>
                
                <div class="text-input-wrapper">
                    <textarea 
                        id="messageInput" 
                        class="message-input" 
                        placeholder="Initializing chat..."
                        rows="1"
                        disabled></textarea>
                </div>
                
                <button id="sendBtn" class="send-btn" type="button" disabled>
                    ‚úàÔ∏è
                </button>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js" crossorigin="anonymous"></script>
    <script src="~/js/chat.js"></script>
    <script>
        (function() {
            let chatSessionId = null;
            let uploadedFilePath = null;
            let uploadedFileType = null;
            let heartbeatTimer = null;
            let sessionTimerInterval = null;
            let sessionExpired = false;
            
            // Voice recording state
            let mediaRecorder = null;
            let audioChunks = [];
            let recordingStream = null;
            let recordingTimer = null;
            let recordingStartTime = null;
            
            const messagesList = document.getElementById('messagesList');
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            const fileInput = document.getElementById('fileInput');
            const filePreviewArea = document.getElementById('filePreviewArea');
            const filePreviewImage = document.getElementById('filePreviewImage');
            const filePreviewName = document.getElementById('filePreviewName');
            const filePreviewSize = document.getElementById('filePreviewSize');
            const removeFileBtn = document.getElementById('removeFileBtn');
            const voiceRecordBtn = document.getElementById('voiceRecordBtn');
            const voiceRecordingIndicator = document.getElementById('voiceRecordingIndicator');
            const recordingTimerEl = document.getElementById('recordingTimer');
            const voiceStopBtn = document.getElementById('voiceStopBtn');
            const voiceCancelBtn = document.getElementById('voiceCancelBtn');
            const messagesWrapper = document.getElementById('messagesWrapper');
            
            function formatFileSize(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            }

            async function sendHeartbeat() {
                try {
                    await fetch('/api/presence/heartbeat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({}), // body is optional; server uses User from claims
                        credentials: 'include'
                    });
                } catch {
                    // swallow errors; presence is best-effort
                }
            }

            async function markMessagesAsSeen() {
                if (!chatSessionId) return;
                try {
                    await fetch('/api/chat/mark-seen', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chatSessionId }),
                        credentials: 'include'
                    });
                } catch { }
            }
            
            function renderMessage(message) {
                if (message.messageType === 'System' || message.role === 'System') {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message message-system';
                    messageDiv.setAttribute('data-message-id', message.messageId || '');
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'message-content message-system-content';
                    const textP = document.createElement('p');
                    textP.className = 'message-text message-system-text';
                    textP.textContent = message.messageText || '';
                    contentDiv.appendChild(textP);
                    messageDiv.appendChild(contentDiv);
                    const emptyState = messagesList.querySelector('.empty-chat-state');
                    if (emptyState) emptyState.remove();
                    messagesList.appendChild(messageDiv);
                    messagesWrapper.scrollTop = messagesWrapper.scrollHeight;
                    return;
                }
                const isUser = message.role === 'User';
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isUser ? 'user-message' : 'admin-message'}`;
                messageDiv.setAttribute('data-message-id', message.messageId || '');
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                
                if (!isUser) {
                    const senderName = document.createElement('div');
                    senderName.className = 'sender-name';
                    senderName.textContent = 'Support Team';
                    contentDiv.appendChild(senderName);
                }
                
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble';
                
                // Handle different message types
                if (message.messageType === 'Image') {
                    const img = document.createElement('img');
                    img.src = message.messageText;
                    img.className = 'message-image';
                    img.alt = 'Shared image';
                    img.onclick = () => window.open(message.messageText, '_blank');
                    bubble.appendChild(img);
                } else if (message.messageType === 'File') {
                    const fileLink = document.createElement('a');
                    fileLink.href = message.messageText;
                    fileLink.className = 'message-file';
                    fileLink.target = '_blank';
                    fileLink.download = '';
                    
                    const fileIcon = document.createElement('div');
                    fileIcon.className = 'file-icon';
                    fileIcon.textContent = 'üìÑ';
                    
                    const fileInfo = document.createElement('div');
                    fileInfo.className = 'file-info';
                    
                    const fileName = document.createElement('div');
                    fileName.className = 'file-name';
                    fileName.textContent = message.messageText.split('/').pop();
                    
                    const fileSize = document.createElement('div');
                    fileSize.className = 'file-size';
                    fileSize.textContent = 'Click to download';
                    
                    fileInfo.appendChild(fileName);
                    fileInfo.appendChild(fileSize);
                    fileLink.appendChild(fileIcon);
                    fileLink.appendChild(fileInfo);
                    bubble.appendChild(fileLink);
                } else if (message.messageType === 'Voice') {
                    const audio = document.createElement('audio');
                    let voiceUrl = message.messageText || '';
                    if (voiceUrl && !voiceUrl.startsWith('/') && !voiceUrl.startsWith('http'))
                        voiceUrl = '/' + voiceUrl;
                    audio.src = voiceUrl;
                    audio.controls = true;
                    audio.className = 'message-voice';
                    audio.preload = 'metadata';
                    bubble.appendChild(audio);
                } else {
                    const textP = document.createElement('p');
                    textP.className = 'message-text';
                    textP.textContent = message.messageText;
                    bubble.appendChild(textP);
                }
                
                const meta = document.createElement('div');
                meta.className = 'message-meta';
                const time = new Date(message.sentAt).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                let metaHTML = `<span>${time}</span>`;
                // Only show Sent/Seen status for user's own messages (not admin messages)
                if (isUser) {
                    const statusText = message.status || 'Sent';
                    const statusIcon = statusText === 'Seen' ? '‚úì‚úì' : '‚úì';
                    metaHTML += ` ¬∑ <span class="message-status" data-message-id="${message.messageId || ''}">${statusIcon} ${statusText}</span>`;
                }
                meta.innerHTML = metaHTML;
                
                contentDiv.appendChild(bubble);
                contentDiv.appendChild(meta);
                messageDiv.appendChild(contentDiv);
                
                // Remove empty state if exists
                const emptyState = messagesList.querySelector('.empty-chat-state');
                if (emptyState) {
                    emptyState.remove();
}
                
                messagesList.appendChild(messageDiv);
                scrollToBottom();
                
                return messageDiv;
            }
            
            function scrollToBottom() {
                messagesWrapper.scrollTop = messagesWrapper.scrollHeight;
            }
            
            async function loadChatHistory() {
                try {
                    const response = await fetch(`/api/chat/history?chatSessionId=${encodeURIComponent(chatSessionId)}`, {
                        credentials: 'include'
                    });
                    
                    if (!response.ok) throw new Error('Failed to load history');
                    
                    const messages = await response.json();
                    messagesList.innerHTML = '';
                    
                    if (messages.length === 0) {
                        messagesList.innerHTML = '<div class="empty-chat-state"><div class="icon">üí¨</div><h3>Start a Conversation</h3><p>Send a message to connect with our support team.</p></div>';
                    } else {
                        messages.forEach(msg => {
                            const message = {
                                messageId: msg.id,
                                messageText: msg.content,
                                messageType: msg.messageType,
                                role: msg.role,
                                sentAt: msg.createdAt,
                                status: msg.isSeen ? 'Seen' : 'Sent'
                            };
                            renderMessage(message);
                        });
                    }

                    // When user opens the chat, mark any unseen admin messages as seen
                    // so the admin dashboard can update Sent -> Seen in real time.
                    await markMessagesAsSeen();
                } catch (err) {
                    console.error('Failed to load history:', err);
                }
            }
            
            async function loadSessionInfo() {
                if (!chatSessionId) return;
                
                try {
                    const response = await fetch(`/api/chat/session-info?chatSessionId=${encodeURIComponent(chatSessionId)}`, {
                        credentials: 'include'
                    });
                    
                    if (!response.ok) return;
                    
                    const sessionInfo = await response.json();
                    
                    if (sessionInfo.isExpired) {
                        handleSessionExpired('DurationExpired');
                        return;
                    }
                    
                    // Show timer
                    const timerEl = document.getElementById('sessionTimer');
                    const timerMinutesEl = document.getElementById('timerMinutes');
                    if (timerEl && timerMinutesEl) {
                        timerEl.style.display = 'flex';
                        updateTimerDisplay(sessionInfo.remainingMinutes);
                        
                        // Start countdown timer (update every 10 seconds)
                        if (sessionTimerInterval) {
                            clearInterval(sessionTimerInterval);
                        }
                        // Update timer more frequently (every 5 seconds) to catch expiration quickly
                        sessionTimerInterval = setInterval(async () => {
                            if (sessionExpired) {
                                clearInterval(sessionTimerInterval);
                                sessionTimerInterval = null;
                                return;
                            }
                            
                            const resp = await fetch(`/api/chat/session-info?chatSessionId=${encodeURIComponent(chatSessionId)}`, {
                                credentials: 'include'
                            });
                            if (resp.ok) {
                                const info = await resp.json();
                                if (info.isExpired) {
                                    handleSessionExpired('DurationExpired');
                                } else {
                                    updateTimerDisplay(info.remainingMinutes);
                                    // If less than 1 minute remaining, check more frequently (every 2 seconds)
                                    if (info.remainingMinutes < 1 && sessionTimerInterval) {
                                        clearInterval(sessionTimerInterval);
                                        sessionTimerInterval = setInterval(async () => {
                                            if (sessionExpired) {
                                                clearInterval(sessionTimerInterval);
                                                sessionTimerInterval = null;
                                                return;
                                            }
                                            const resp2 = await fetch(`/api/chat/session-info?chatSessionId=${encodeURIComponent(chatSessionId)}`, {
                                                credentials: 'include'
                                            });
                                            if (resp2.ok) {
                                                const info2 = await resp2.json();
                                                if (info2.isExpired) {
                                                    handleSessionExpired('DurationExpired');
                                                } else {
                                                    updateTimerDisplay(info2.remainingMinutes);
                                                }
                                            }
                                        }, 2000); // Check every 2 seconds when close to expiration
                                    }
                                }
                            }
                        }, 5000); // Update every 5 seconds normally
                    }
                } catch (err) {
                    console.error('Failed to load session info:', err);
                }
            }
            
            function updateTimerDisplay(remainingMinutes) {
                const timerMinutesEl = document.getElementById('timerMinutes');
                if (timerMinutesEl) {
                    timerMinutesEl.textContent = Math.ceil(remainingMinutes);
                }
                
                // Check if session expired (remainingMinutes <= 0)
                if (remainingMinutes <= 0 && !sessionExpired) {
                    handleSessionExpired('DurationExpired');
                }
            }
            
            function handleSessionExpired(reason) {
                sessionExpired = true;
                const isIdleTerminated = reason === 'IdleTerminated';
                
                // Stop timer updates
                if (sessionTimerInterval) {
                    clearInterval(sessionTimerInterval);
                    sessionTimerInterval = null;
                }
                
                // Hide timer
                const timerEl = document.getElementById('sessionTimer');
                if (timerEl) {
                    timerEl.style.display = 'none';
                }
                
                // Disable input
                const messageInput = document.getElementById('messageInput');
                const sendBtn = document.getElementById('sendBtn');
                if (messageInput) {
                    messageInput.disabled = true;
                    messageInput.placeholder = isIdleTerminated
                        ? 'The chat was terminated because we did not receive a response from you.'
                        : 'Your chat session has expired';
                }
                if (sendBtn) {
                    sendBtn.disabled = true;
                }
                
                const inlineMessage = isIdleTerminated
                    ? 'The chat was terminated because we did not receive a response from you. Click "Start New Chat Session" below to continue.'
                    : 'Your chat session has expired. Click "Start New Chat Session" below to continue.';
                const bannerMessage = isIdleTerminated
                    ? 'The chat was terminated because we did not receive a response from you.'
                    : 'Your chat session has expired.';
                const titleText = isIdleTerminated ? 'Chat Terminated' : 'Session Expired';
                
                // Set banner text first (by id so it always updates) then show banner
                const bannerTextEl = document.getElementById('expiredSessionBannerText');
                if (bannerTextEl) {
                    bannerTextEl.textContent = bannerMessage;
                }
                
                // Show expiration message in chat area (with id so we can remove it when starting new session)
                const messagesList = document.getElementById('messagesList');
                if (messagesList && !document.getElementById('expiredSessionMessage')) {
                    const expiredMsg = document.createElement('div');
                    expiredMsg.id = 'expiredSessionMessage';
                    expiredMsg.className = 'expired-session-message';
                    expiredMsg.innerHTML = '<div class="icon">‚è∞</div><h3>' + titleText + '</h3><p>' + inlineMessage + '</p>';
                    messagesList.appendChild(expiredMsg);
                }
                
                // Show expired session banner
                const banner = document.getElementById('expiredSessionBanner');
                if (banner) {
                    banner.classList.remove('d-none');
                }
            }
            
            async function startNewSession() {
                const btn = document.getElementById('startNewSessionBtn');
                if (btn) btn.disabled = true;
                
                const oldChatSessionId = chatSessionId;
                
                try {
                    // GET /api/chat/my-session creates/returns new session if current was expired
                    const response = await fetch('/api/chat/my-session', {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    if (!response.ok) throw new Error('Failed to start new session');
                    
                    const data = await response.json();
                    const newChatSessionId = data.chatSessionId;
                    
                    if (!newChatSessionId) throw new Error('No session ID received');
                    
                    // Leave old SignalR group
                    if (oldChatSessionId) {
                        await ChatClient.leaveChat(oldChatSessionId);
                    }
                    
                    chatSessionId = newChatSessionId;
                    sessionExpired = false;
                    
                    // Join new SignalR group
                    await ChatClient.joinChat(chatSessionId);
                    
                    // Clear old messages and show empty state (read-only history cleared)
                    const messagesList = document.getElementById('messagesList');
                    if (messagesList) {
                        messagesList.innerHTML = '';
                        const emptyState = document.createElement('div');
                        emptyState.className = 'empty-chat-state';
                        emptyState.innerHTML = '<div class="icon">üí¨</div><h3>Start a Conversation</h3><p>Send a message to connect with our support team. We typically respond within a few minutes.</p>';
                        messagesList.appendChild(emptyState);
                    }
                    
                    // Remove expired session banner
                    const banner = document.getElementById('expiredSessionBanner');
                    if (banner) banner.classList.add('d-none');
                    
                    // Re-enable input and send button
                    const messageInput = document.getElementById('messageInput');
                    const sendBtn = document.getElementById('sendBtn');
                    if (messageInput) {
                        messageInput.disabled = false;
                        messageInput.placeholder = 'Type a message...';
                    }
                    if (sendBtn) sendBtn.disabled = false;
                    
                    // Start new countdown timer
                    await loadSessionInfo();
                    
                    // Send heartbeat for presence
                    await sendHeartbeat();
                } catch (err) {
                    console.error('Failed to start new session:', err);
                    alert('Failed to start new session. Please try again.');
                } finally {
                    const startBtn = document.getElementById('startNewSessionBtn');
                    if (startBtn) startBtn.disabled = false;
                }
            }
            
            async function initChat() {
                try {
                    // Disable input while initializing
                    const messageInput = document.getElementById('messageInput');
                    const sendBtn = document.getElementById('sendBtn');
                    if (messageInput) messageInput.disabled = true;
                    if (sendBtn) sendBtn.disabled = true;
                    
                    // Get or create the user's chat session
                    const response = await fetch('/api/chat/my-session', {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    if (!response.ok) throw new Error('Failed to get session');
                    
                    const data = await response.json();
                    chatSessionId = data.chatSessionId;
                    
                    if (!chatSessionId) {
                        throw new Error('No chat session ID received');
                    }
                    
                    // Join SignalR group
                    await ChatClient.joinChat(chatSessionId);
                    
                    // Load chat history
                    await loadChatHistory();

                    // Load session info and start countdown timer
                    await loadSessionInfo();

                    // Start periodic presence heartbeat so admin can see Online/Idle/Offline
                    await sendHeartbeat();
                    if (!heartbeatTimer) {
                        heartbeatTimer = setInterval(sendHeartbeat, 30000); // every 30s
                    }
                    
                    // Enable input after successful initialization
                    if (messageInput && !sessionExpired) messageInput.disabled = false;
                    if (sendBtn && !sessionExpired) sendBtn.disabled = false;
                } catch (err) {
                    console.error('Failed to init chat:', err);
                    messagesList.innerHTML = '<div class="empty-chat-state"><div class="icon">‚ùå</div><h3>Error</h3><p>Failed to connect to chat. Please refresh the page.</p></div>';
                    // Keep input disabled on error
                }
            }
            
            // File upload handling
            fileInput.addEventListener('change', async function() {
                const file = this.files[0];
                if (!file) return;
                
                // Show preview
                filePreviewArea.classList.remove('d-none');
                filePreviewName.textContent = file.name;
                filePreviewSize.textContent = formatFileSize(file.size);
                
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        filePreviewImage.src = e.target.result;
                        filePreviewImage.classList.remove('d-none');
                    };
                    reader.readAsDataURL(file);
                } else {
                    filePreviewImage.classList.add('d-none');
                }
                
                // Upload file
                const formData = new FormData();
                formData.append('file', file);
                
                try {
                    sendBtn.disabled = true;
                    const response = await fetch('/api/chat/upload-file', {
                        method: 'POST',
                        body: formData,
                        credentials: 'include'
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.message || 'Upload failed');
                    }
                    
                    const data = await response.json();
                    uploadedFilePath = data.filePath;
                    uploadedFileType = data.fileType;
                } catch (err) {
                    alert('File upload failed: ' + err.message);
                    clearFileUpload();
                } finally {
                    sendBtn.disabled = false;
                }
            });
            
            removeFileBtn.addEventListener('click', clearFileUpload);
            
            function clearFileUpload() {
                fileInput.value = '';
                filePreviewArea.classList.add('d-none');
                filePreviewImage.src = '';
                filePreviewImage.classList.add('d-none');
                uploadedFilePath = null;
                uploadedFileType = null;
            }
            
            // Voice recording functions
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            function updateRecordingTimer() {
                if (recordingStartTime) {
                    const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                    recordingTimerEl.textContent = formatTime(elapsed);
                }
            }
            
            function stopRecordingTimer() {
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                recordingStartTime = null;
            }
            
            async function startVoiceRecording() {
                try {
                    if (!chatSessionId) {
                        alert('Please wait for chat to initialize.');
                        return;
                    }
                    
                    // Request microphone permission
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    recordingStream = stream;
                    
                    // Determine MIME type (prefer webm with opus codec)
                    let mimeType = 'audio/webm;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/webm';
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = ''; // Use browser default
                        }
                    }
                    
                    // Create MediaRecorder
                    mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
                        await uploadVoiceRecording(audioBlob);
                        
                        // Stop all tracks
                        if (recordingStream) {
                            recordingStream.getTracks().forEach(track => track.stop());
                            recordingStream = null;
                        }
                    };
                    
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event);
                        alert('Recording error occurred. Please try again.');
                        cancelVoiceRecording();
                    };
                    
                    // Start recording
                    mediaRecorder.start();
                    recordingStartTime = Date.now();
                    recordingTimer = setInterval(updateRecordingTimer, 1000);
                    
                    // Update UI
                    voiceRecordBtn.classList.add('d-none');
                    voiceRecordingIndicator.classList.remove('d-none');
                    messageInput.disabled = true;
                    sendBtn.disabled = true;
                    
                } catch (err) {
                    console.error('Error starting recording:', err);
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        alert('Microphone permission denied. Please allow microphone access and try again.');
                    } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                        alert('No microphone found. Please connect a microphone and try again.');
                    } else {
                        alert('Failed to start recording: ' + err.message);
                    }
                }
            }
            
            function stopVoiceRecording() {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
                stopRecordingTimer();
                
                // Update UI
                voiceRecordBtn.classList.remove('d-none');
                voiceRecordingIndicator.classList.add('d-none');
                messageInput.disabled = false;
                sendBtn.disabled = false;
            }
            
            function cancelVoiceRecording() {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
                
                // Stop all tracks
                if (recordingStream) {
                    recordingStream.getTracks().forEach(track => track.stop());
                    recordingStream = null;
                }
                
                audioChunks = [];
                stopRecordingTimer();
                
                // Update UI
                voiceRecordBtn.classList.remove('d-none');
                voiceRecordingIndicator.classList.add('d-none');
                messageInput.disabled = false;
                sendBtn.disabled = false;
            }
            
            async function uploadVoiceRecording(audioBlob) {
                try {
                    sendBtn.disabled = true;
                    
                    const formData = new FormData();
                    // Determine file extension from MIME type
                    let extension = '.webm';
                    if (audioBlob.type.includes('ogg')) extension = '.ogg';
                    else if (audioBlob.type.includes('mp4') || audioBlob.type.includes('m4a')) extension = '.m4a';
                    else if (audioBlob.type.includes('wav')) extension = '.wav';
                    
                    const fileName = `recording${extension}`;
                    formData.append('file', audioBlob, fileName);
                    
                    const response = await fetch('/api/chat/upload-voice', {
                        method: 'POST',
                        body: formData,
                        credentials: 'include'
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.message || 'Upload failed');
                    }
                    
                    const data = await response.json();
                    
                    // Send voice message via SignalR
                    if (!chatSessionId) {
                        alert('Chat session not initialized. Please wait...');
                        return;
                    }
                    await ChatClient.sendMessageTo(chatSessionId, data.filePath, 'Voice');
                    
                } catch (err) {
                    alert('Voice upload failed: ' + err.message);
                } finally {
                    sendBtn.disabled = false;
                }
            }
            
            // Voice recording event listeners
            voiceRecordBtn.addEventListener('click', startVoiceRecording);
            voiceStopBtn.addEventListener('click', stopVoiceRecording);
            voiceCancelBtn.addEventListener('click', cancelVoiceRecording);
            
            // File upload handling
            fileInput.addEventListener('change', async function() {
                if (sessionExpired) {
                    alert('Your chat session has expired. Please refresh the page to start a new session.');
                    this.value = ''; // Clear file selection
                    return;
                }
                
                const file = this.files[0];
                if (!file) return;
                
                // Show preview
                filePreviewArea.classList.remove('d-none');
                filePreviewName.textContent = file.name;
                filePreviewSize.textContent = formatFileSize(file.size);
                
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        filePreviewImage.src = e.target.result;
                        filePreviewImage.classList.remove('d-none');
                    };
                    reader.readAsDataURL(file);
                } else {
                    filePreviewImage.classList.add('d-none');
                }
                
                // Upload file
                const formData = new FormData();
                formData.append('file', file);
                
                try {
                    sendBtn.disabled = true;
                    const response = await fetch('/api/chat/upload-file', {
                        method: 'POST',
                        body: formData,
                        credentials: 'include'
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.message || 'Upload failed');
                    }
                    
                    const data = await response.json();
                    uploadedFilePath = data.filePath;
                    uploadedFileType = data.fileType === 'image' ? 'image' : 'file';
                } catch (err) {
                    // Check if error is due to session expiration
                    if (err.message && (err.message.includes('expired') || err.message.includes('session'))) {
                        handleSessionExpired('DurationExpired');
                        alert('Your chat session has expired. Please refresh the page to start a new session.');
                    } else {
                        alert('File upload failed: ' + err.message);
                    }
                    clearFileUpload();
                } finally {
                    if (!sessionExpired) {
                        sendBtn.disabled = false;
                    }
                }
            });
            
            // Start New Chat Session button (when session expires)
            const startNewSessionBtn = document.getElementById('startNewSessionBtn');
            if (startNewSessionBtn) {
                startNewSessionBtn.addEventListener('click', startNewSession);
            }
            
            // Voice recording event listeners
            voiceRecordBtn.addEventListener('click', startVoiceRecording);
            voiceStopBtn.addEventListener('click', stopVoiceRecording);
            voiceCancelBtn.addEventListener('click', cancelVoiceRecording);
            
            // Send message
            sendBtn.addEventListener('click', async function() {
                if (sessionExpired) {
                    alert('Your chat session has expired. Please refresh the page to start a new session.');
                    return;
                }
                
                const text = messageInput.value.trim();
                if (!text && !uploadedFilePath) return;
                
                try {
                    sendBtn.disabled = true;
                    
                    if (uploadedFilePath) {
                        // Send file message
                        if (!chatSessionId) {
                            alert('Chat session not initialized. Please wait...');
                            return;
                        }
                        const messageType = uploadedFileType === 'image' ? 'Image' : 'File';
                        await ChatClient.sendMessageTo(chatSessionId, uploadedFilePath, messageType);
                        clearFileUpload();
                    } else {
                        // Send text message
                        if (!chatSessionId) {
                            alert('Chat session not initialized. Please wait...');
                            return;
                        }
                        await ChatClient.sendMessageTo(chatSessionId, text, 'Text');
                    }
                    
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                } catch (err) {
                    // Check if error is due to session expiration
                    if (err.message && (err.message.includes('expired') || err.message.includes('session'))) {
                        handleSessionExpired('DurationExpired');
                        alert('Your chat session has expired. Please refresh the page to start a new session.');
                    } else {
                        alert('Failed to send: ' + err.message);
                    }
                } finally {
                    if (!sessionExpired) {
                        sendBtn.disabled = false;
                    }
                }
            });
            
            // Enter to send
            messageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (!sessionExpired) {
                        sendBtn.click();
                    }
                }
            });
            
            // Auto-resize textarea
            messageInput.addEventListener('input', function() {
                if (!sessionExpired) {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                }
            });
            
            // Initialize
            async function init() {
                await ChatClient.init(function(message) {
                    if (message.chatSessionId === chatSessionId) {
                        renderMessage(message);

                        // If an admin message arrives while user is viewing the chat,
                        // mark it seen immediately so admin UI updates.
                        if (message.role !== 'User') {
                            markMessagesAsSeen();
                        }
                    }
                });
                
                // Register SessionEnded handler
                ChatClient.onSessionEnded(function(data) {
                    if (data.chatSessionId === chatSessionId) {
                        handleSessionExpired(data.reason);
                    }
                });
                
                // Listen for status changes
                ChatClient.onMessageStatusChanged(function(event) {
                    if (event.chatSessionId === chatSessionId) {
                        event.messageIds.forEach(messageId => {
                            const statusSpan = document.querySelector(`.message-status[data-message-id="${messageId}"]`);
                            if (statusSpan) {
                                const statusText = event.status || 'Sent';
                                const statusIcon = statusText === 'Seen' ? '‚úì‚úì' : '‚úì';
                                statusSpan.textContent = `${statusIcon} ${statusText}`;
                            }
                        });
                    }
                });
                
                await initChat();
                
                const userLogoutBtn = document.getElementById('userLogoutBtn');
                const userLogoutForm = document.getElementById('userLogoutForm');
                if (userLogoutBtn && userLogoutForm) {
                    userLogoutBtn.addEventListener('click', function() {
                        if (typeof ChatClient !== 'undefined' && typeof ChatClient.stop === 'function') {
                            ChatClient.stop().then(function() { userLogoutForm.submit(); });
                        } else {
                            userLogoutForm.submit();
                        }
                    });
                }
            }
            
            document.addEventListener('DOMContentLoaded', init);
        })();
    </script>
}
