@page
@model LiveChatTask.Pages.Admin.IndexModel
@{
    ViewData["Title"] = "Admin Dashboard";
}

<link rel="stylesheet" href="~/css/admin-dashboard.css" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

<style>
    body { font-family: 'Inter', sans-serif; margin: 0; }
    .settings-panel { background: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
    .settings-panel h5 { margin-top: 0; color: #667eea; }
    .settings-panel label { font-weight: 500; font-size: 0.9rem; color: #4b5563; margin-bottom: 0.5rem; display: block; }
    .settings-panel input { width: 100%; padding: 0.5rem; border: 2px solid #e5e7eb; border-radius: 8px; }
    .settings-panel .btn-primary { background: linear-gradient(135deg, #667eea, #764ba2); border: none; padding: 0.5rem 1rem; border-radius: 8px; color: white; cursor: pointer; }
    .settings-panel .btn-primary:hover { opacity: 0.9; }
    .chat-tabs-container { background: white; border-bottom: 2px solid #e5e7eb; padding: 0.75rem 1.5rem; }
    .chat-tabs { display: flex; gap: 8px; flex-wrap: wrap; }
    .chat-tab { background: #f3f4f6; border: none; padding: 0.5rem 1rem; border-radius: 8px 8px 0 0; cursor: pointer; display: flex; align-items: center; gap: 8px; font-weight: 500; transition: all 0.2s; }
    .chat-tab:hover { background: #e5e7eb; }
    .chat-tab.active { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
    .chat-tab-close { margin-left: 8px; cursor: pointer; font-weight: bold; }
    .chat-tab-close:hover { color: #ef4444; }
    .chat-panels { flex: 1; overflow-y: auto; }
    .chat-panel { height: 100%; overflow-y: auto; padding: 1.5rem; }
    .three-column-layout { display: flex; gap: 1rem; height: calc(100vh - 20px); padding: 10px; }
    .sidebar-col { width: 320px; }
    .main-col { flex: 1; display: flex; flex-direction: column; background: white; border-radius: 12px; overflow: hidden; }
    .settings-col { width: 300px; }
</style>

<div class="three-column-layout">
    <!-- Left Sidebar: Users -->
    <div class="sidebar-col">
        <div class="admin-sidebar">
            <div class="sidebar-header">
                <h2>üí¨ Chat Dashboard <span class="admin-badge">Admin</span></h2>
            </div>
            <div class="user-list">
                <div class="user-list-header">Active Conversations</div>
                <div id="adminUsersLoading" class="text-center p-3">Loading users...</div>
                <div id="adminUsersContainer"></div>
            </div>
        </div>
    </div>

    <!-- Main: Multi-tab Chats -->
    <div class="main-col">
        <div class="chat-header">
            <div class="chat-header-info">
                <h3>Support Console</h3>
                <div class="status-indicator"><span class="dot online"></span> Connected</div>
            </div>
            <div class="chat-actions">
                <button type="button" onclick="location.reload()">üîÑ Refresh</button>
                <form id="adminLogoutForm" method="post" asp-page-handler="Logout" style="display: inline;">
                    <button type="button" id="adminLogoutBtn">Logout</button>
                </form>
            </div>
        </div>

        <!-- Tabs -->
        <div class="chat-tabs-container">
            <div id="adminChatTabs" class="chat-tabs"></div>
        </div>

        <!-- Chat Panels -->
        <div id="adminChatPanels" class="chat-panels">
            <div class="empty-state" style="height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                <div class="empty-state-icon">üí¨</div>
                <h3>Welcome to Admin Dashboard</h3>
                <p>Select a user from the left to open a chat tab.</p>
            </div>
        </div>

        <!-- Message Input -->
        <div class="message-input-container">
            <div id="filePreviewContainer" class="file-preview d-none">
                <img id="filePreviewImage" src="" alt="Preview" class="d-none" />
                <div class="file-preview-info">
                    <strong id="filePreviewName"></strong>
                    <div id="filePreviewSize" class="file-size"></div>
                </div>
                <button type="button" class="remove-file" id="removeFileBtn">Remove</button>
            </div>
            <div class="message-input-wrapper">
                <label class="file-upload-btn">üìé <input type="file" id="fileInput" accept="image/*,.pdf,.doc,.docx,.txt" /></label>
                <button id="voiceRecordBtn" class="voice-record-btn" type="button" title="Record voice message">üé§</button>
                <div id="voiceRecordingIndicator" class="voice-recording-indicator d-none">
                    <span class="recording-dot"></span>
                    <span id="recordingTimer">00:00</span>
                    <button id="voiceStopBtn" type="button" class="voice-stop-btn">Stop</button>
                    <button id="voiceCancelBtn" type="button" class="voice-cancel-btn">Cancel</button>
                </div>
                <div class="input-wrapper">
                    <textarea id="messageInput" class="message-input" placeholder="Type your message..." rows="1" disabled></textarea>
                </div>
                <button id="sendButton" class="send-button" type="button" disabled>‚úàÔ∏è</button>
            </div>
        </div>
    </div>

    <!-- Right Sidebar: Settings -->
    <div class="settings-col">
        <div class="settings-panel">
            <h5>Chat Settings</h5>
            <div style="margin-bottom: 1rem;">
                <label>Max characters per message</label>
                <input id="adminMaxCharsInput" type="number" value="500" min="10" max="5000" />
                <div style="font-size: 0.85rem; color: #6b7280; margin-top: 4px;">Applies to user messages only.</div>
            </div>
            <div style="margin-bottom: 1rem;">
                <label>Max session duration (minutes)</label>
                <input id="adminMaxDurationInput" type="number" value="60" min="1" max="1440" />
                <div style="font-size: 0.85rem; color: #6b7280; margin-top: 4px;">Maximum duration for user chat sessions (1-1440 minutes = 1 minute to 24 hours).</div>
            </div>
            <div style="margin-top: 0.75rem;">
                <button id="adminSaveSettingsBtn" type="button" class="btn-primary">Save</button>
                <span id="adminSettingsStatus" style="margin-left: 8px; font-size: 0.85rem; color: #6b7280;"></span>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js" crossorigin="anonymous"></script>
    <script src="~/js/chat.js"></script>
    <script>
(function() {
    const openChats = {}; // chatSessionId => { userId, userLabel, panelEl }
    const unreadByUserId = {}; // userId => unread count (for notification badges)
    let activeChatSessionId = null;
    let uploadedFilePath = null;
    let uploadedFileType = null;
    
    // Voice recording state
    let mediaRecorder = null;
    let audioChunks = [];
    let recordingStream = null;
    let recordingTimer = null;
    let recordingStartTime = null;
    
    const tabs = document.getElementById('adminChatTabs');
    const panelsHost = document.getElementById('adminChatPanels');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    const fileInput = document.getElementById('fileInput');
    const filePreviewContainer = document.getElementById('filePreviewContainer');
    const filePreviewImage = document.getElementById('filePreviewImage');
    const filePreviewName = document.getElementById('filePreviewName');
    const filePreviewSize = document.getElementById('filePreviewSize');
    const removeFileBtn = document.getElementById('removeFileBtn');
    const voiceRecordBtn = document.getElementById('voiceRecordBtn');
    const voiceRecordingIndicator = document.getElementById('voiceRecordingIndicator');
    const recordingTimerEl = document.getElementById('recordingTimer');
    const voiceStopBtn = document.getElementById('voiceStopBtn');
    const voiceCancelBtn = document.getElementById('voiceCancelBtn');
    const usersContainer = document.getElementById('adminUsersContainer');
    const usersLoading = document.getElementById('adminUsersLoading');
    const maxCharsInput = document.getElementById('adminMaxCharsInput');
    const maxDurationInput = document.getElementById('adminMaxDurationInput');
    const saveSettingsBtn = document.getElementById('adminSaveSettingsBtn');
    const settingsStatus = document.getElementById('adminSettingsStatus');
    
    const storageKey = 'adminOpenChats';
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text || '';
        return div.innerHTML;
    }
    
    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }
    
    function saveOpenChatsToStorage() {
        try {
            const items = Object.keys(openChats).map(id => ({
                chatSessionId: id,
                userId: openChats[id].userId,
                userLabel: openChats[id].userLabel
            }));
            localStorage.setItem(storageKey, JSON.stringify(items));
        } catch { }
    }
    
    function loadOpenChatsFromStorage() {
        try {
            const raw = localStorage.getItem(storageKey);
            if (!raw) return [];
            const parsed = JSON.parse(raw);
            return Array.isArray(parsed) ? parsed : [];
        } catch {
            return [];
        }
    }
    
    function updateUnreadBadge(userId, count) {
        unreadByUserId[userId] = count;
        const badge = document.getElementById('unread-badge-' + userId);
        if (badge) {
            if (count > 0) {
                badge.textContent = count > 99 ? '99+' : count;
                badge.style.display = '';
            } else {
                badge.style.display = 'none';
            }
        }
    }
    
    async function setActiveChat(chatSessionId) {
        activeChatSessionId = chatSessionId;
        messageInput.disabled = !chatSessionId;
        sendButton.disabled = !chatSessionId;
        
        tabs.querySelectorAll('.chat-tab').forEach(btn => {
            btn.classList.toggle('active', btn.getAttribute('data-chat-session-id') === chatSessionId);
        });
        
        Object.keys(openChats).forEach(id => {
            const panel = openChats[id].panelEl;
            if (id === chatSessionId) {
                panel.classList.remove('d-none');
            } else {
                panel.classList.add('d-none');
            }
        });
        
        const panel = openChats[chatSessionId]?.panelEl;
        if (panel) panel.scrollTop = panel.scrollHeight;
        
        if (chatSessionId) {
            await markMessagesAsSeen(chatSessionId);
            const chat = openChats[chatSessionId];
            if (chat && chat.userId) {
                updateUnreadBadge(chat.userId, 0);
            }
        }
    }
    
    async function markMessagesAsSeen(chatSessionId) {
        if (!chatSessionId) return;
        try {
            await fetch('/api/chat/mark-seen', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ chatSessionId }),
                credentials: 'include'
            });
        } catch { }
    }
    
    function createPanel(chatSessionId) {
        const panel = document.createElement('div');
        panel.className = 'chat-panel d-none';
        panel.innerHTML = '<div style="text-align:center; color: #9ca3af;">Loading history...</div>';
        return panel;
    }

    function removeEmptyStateIfPresent() {
        const empty = panelsHost.querySelector('.empty-state');
        if (empty) empty.remove();
    }
    
    function renderMessage(message, panelEl) {
        const isAdmin = message.role === 'Admin';
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isAdmin ? 'sent' : 'received'}`;
        messageDiv.setAttribute('data-message-id', message.messageId || '');
        
        const avatar = document.createElement('div');
        avatar.className = 'message-avatar';
        avatar.textContent = isAdmin ? 'A' : 'U';
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        
        if (message.messageType === 'Image') {
            const img = document.createElement('img');
            img.src = message.messageText;
            img.className = 'message-image';
            img.alt = 'Shared image';
            img.onclick = () => window.open(message.messageText, '_blank');
            bubble.appendChild(img);
        } else if (message.messageType === 'File') {
            const fileLink = document.createElement('a');
            fileLink.href = message.messageText;
            fileLink.className = 'message-file';
            fileLink.target = '_blank';
            fileLink.download = '';
            
            const fileIcon = document.createElement('div');
            fileIcon.className = 'file-icon';
            fileIcon.textContent = 'üìÑ';
            
            const fileInfo = document.createElement('div');
            fileInfo.className = 'file-info';
            
            const fileName = document.createElement('div');
            fileName.className = 'file-name';
            fileName.textContent = message.messageText.split('/').pop();
            
            fileInfo.appendChild(fileName);
            fileLink.appendChild(fileIcon);
            fileLink.appendChild(fileInfo);
            bubble.appendChild(fileLink);
        } else if (message.messageType === 'Voice') {
            const audio = document.createElement('audio');
            audio.src = message.messageText;
            audio.controls = true;
            audio.className = 'message-voice';
            audio.preload = 'metadata';
            bubble.appendChild(audio);
        } else {
            const textP = document.createElement('p');
            textP.className = 'message-text';
            textP.textContent = message.messageText;
            bubble.appendChild(textP);
        }
        
        const meta = document.createElement('div');
        meta.className = 'message-meta';
        const time = new Date(message.sentAt).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        let metaHTML = `<span>${time}</span>`;
        // Only show Sent/Seen status for admin's own messages (not user messages)
        if (isAdmin) {
            const statusText = message.status || 'Sent';
            const statusIcon = statusText === 'Seen' ? '‚úì‚úì' : '‚úì';
            metaHTML += ` ¬∑ <span class="message-status" data-message-id="${message.messageId || ''}">${statusIcon} ${statusText}</span>`;
        }
        meta.innerHTML = metaHTML;
        
        contentDiv.appendChild(bubble);
        contentDiv.appendChild(meta);
        messageDiv.appendChild(avatar);
        messageDiv.appendChild(contentDiv);
        
        panelEl.appendChild(messageDiv);
        panelEl.scrollTop = panelEl.scrollHeight;
    }
    
    async function loadChatHistory(chatSessionId) {
        const panelEl = openChats[chatSessionId]?.panelEl;
        if (!panelEl) return;
        
        try {
            const response = await fetch(`/api/chat/history?chatSessionId=${encodeURIComponent(chatSessionId)}`, {
                credentials: 'include'
            });
            
            if (!response.ok) throw new Error('Failed to load history');
            
            const messages = await response.json();
            panelEl.innerHTML = '';
            
            messages.forEach(msg => {
                const message = {
                    messageId: msg.id,
                    messageText: msg.content,
                    messageType: msg.messageType,
                    role: msg.role,
                    sentAt: msg.createdAt,
                    status: msg.isSeen ? 'Seen' : 'Sent'
                };
                renderMessage(message, panelEl);
            });
            
            await markMessagesAsSeen(chatSessionId);
        } catch (err) {
            panelEl.innerHTML = '<div style="color: #ef4444;">Failed to load history.</div>';
        }
    }
    
    async function openChatForUser(userId, userLabel, existingChatSessionId) {
        let chatSessionId = existingChatSessionId;
        if (!chatSessionId) {
            const response = await fetch('/api/chat/open', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ userId }),
                credentials: 'include'
            });
            
            if (!response.ok) {
                alert('Failed to open chat.');
                return;
            }
            
            const body = await response.json();
            chatSessionId = body.chatSessionId;
        }
        
        await ChatClient.joinChat(chatSessionId);
        
        if (!openChats[chatSessionId]) {
            // Create tab
            const tabBtn = document.createElement('button');
            tabBtn.type = 'button';
            tabBtn.className = 'chat-tab';
            tabBtn.setAttribute('data-chat-session-id', chatSessionId);
            
            const labelSpan = document.createElement('span');
            labelSpan.textContent = userLabel;
            
            const closeBtn = document.createElement('span');
            closeBtn.className = 'chat-tab-close';
            closeBtn.textContent = '√ó';
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                closeChatTab(chatSessionId);
            };
            
            tabBtn.appendChild(labelSpan);
            tabBtn.appendChild(closeBtn);
            tabBtn.onclick = () => setActiveChat(chatSessionId);
            tabs.appendChild(tabBtn);
            
            // Create panel
            const panelEl = createPanel(chatSessionId);
            // Only remove the initial empty-state placeholder.
            // Do NOT clear the whole container, otherwise previously opened panels disappear.
            removeEmptyStateIfPresent();
            panelsHost.appendChild(panelEl);
            
            openChats[chatSessionId] = { userId, userLabel, panelEl };
            saveOpenChatsToStorage();
            
            await loadChatHistory(chatSessionId);
        }
        
        await setActiveChat(chatSessionId);
    }
    
    function closeChatTab(chatSessionId) {
        const chat = openChats[chatSessionId];
        if (!chat) return;
        
        const tabBtn = tabs.querySelector(`.chat-tab[data-chat-session-id="${chatSessionId}"]`);
        if (tabBtn) tabBtn.remove();
        
        if (chat.panelEl) chat.panelEl.remove();
        
        delete openChats[chatSessionId];
        saveOpenChatsToStorage();
        
        const remainingIds = Object.keys(openChats);
        if (activeChatSessionId === chatSessionId) {
            activeChatSessionId = remainingIds.length ? remainingIds[0] : null;
            if (activeChatSessionId) setActiveChat(activeChatSessionId);
            else {
                panelsHost.innerHTML = '<div class="empty-state" style="height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;"><div class="empty-state-icon">üí¨</div><h3>No chats open</h3><p>Select a user to open a chat.</p></div>';
                messageInput.disabled = true;
                sendButton.disabled = true;
            }
        }
    }
    
    async function loadUsers() {
        try {
            const response = await fetch('/api/chat/sessions', { credentials: 'include' });
            if (!response.ok) throw new Error('Failed to load users');
            
            const sessions = await response.json();
            usersLoading.style.display = 'none';
            usersContainer.innerHTML = '';
            
            sessions.forEach(session => {
                unreadByUserId[session.userId] = session.unreadCount || 0;
                
                const userCard = document.createElement('div');
                userCard.className = 'user-card';
                userCard.setAttribute('data-user-id', session.userId);
                userCard.onclick = () => openChatForUser(session.userId, session.userNameOrEmail);
                
                const header = document.createElement('div');
                header.className = 'user-card-header';
                
                const avatar = document.createElement('div');
                avatar.className = 'user-avatar';
                avatar.textContent = session.userNameOrEmail.charAt(0).toUpperCase();
                
                const statusDot = document.createElement('div');
                statusDot.className = 'user-status-dot offline';
                statusDot.id = 'status-' + session.userId;
                avatar.appendChild(statusDot);
                
                const info = document.createElement('div');
                info.className = 'user-info';
                const name = document.createElement('h4');
                name.textContent = session.userNameOrEmail;
                const status = document.createElement('p');
                status.textContent = 'Offline';
                status.id = 'status-text-' + session.userId;
                info.appendChild(name);
                info.appendChild(status);
                
                header.appendChild(avatar);
                header.appendChild(info);
                
                const badge = document.createElement('span');
                badge.className = 'unread-badge';
                badge.id = 'unread-badge-' + session.userId;
                badge.textContent = (session.unreadCount || 0) > 99 ? '99+' : (session.unreadCount || 0);
                badge.style.display = (session.unreadCount || 0) > 0 ? '' : 'none';
                header.appendChild(badge);
                
                userCard.appendChild(header);
                usersContainer.appendChild(userCard);
            });
            
            loadPresence();
        } catch (err) {
            usersLoading.textContent = 'Failed to load users';
        }
    }
    
    async function loadPresence() {
        try {
            const response = await fetch('/api/presence/users', { credentials: 'include' });
            if (!response.ok) return;
            
            const users = await response.json();
            users.forEach(user => {
                const dot = document.getElementById('status-' + user.userId);
                const text = document.getElementById('status-text-' + user.userId);
                if (dot) {
                    const statusClass = user.status === 'Online'
                        ? 'online'
                        : (user.status === 'Idle' ? 'idle' : 'offline');
                    dot.className = 'user-status-dot ' + statusClass;
                }
                if (text) {
                    if (user.status === 'Online') text.textContent = 'Online';
                    else if (user.status === 'Idle') text.textContent = 'Idle';
                    else text.textContent = 'Last seen: ' + new Date(user.lastSeen).toLocaleString();
                }
            });
        } catch { }
    }
    
    async function loadChatSettings() {
        try {
            const resp = await fetch('/api/settings/chat', { credentials: 'include' });
            if (!resp.ok) return;
            const data = await resp.json();
            if (typeof data.maxUserMessageLength === 'number') {
                maxCharsInput.value = data.maxUserMessageLength;
            }
            if (typeof data.maxSessionDurationMinutes === 'number') {
                maxDurationInput.value = data.maxSessionDurationMinutes;
            }
        } catch { }
    }
    
    async function saveChatSettings() {
        const maxCharsValue = parseInt(maxCharsInput.value, 10);
        const maxDurationValue = parseInt(maxDurationInput.value, 10);
        
        if (!Number.isFinite(maxCharsValue) || maxCharsValue < 10 || maxCharsValue > 5000) {
            settingsStatus.textContent = 'Invalid max chars (10-5000).';
            return;
        }
        
        if (!Number.isFinite(maxDurationValue) || maxDurationValue < 1 || maxDurationValue > 1440) {
            settingsStatus.textContent = 'Invalid max duration (1-1440 minutes).';
            return;
        }
        
        settingsStatus.textContent = 'Saving...';
        saveSettingsBtn.disabled = true;
        try {
            const resp = await fetch('/api/settings/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    maxUserMessageLength: maxCharsValue,
                    maxSessionDurationMinutes: maxDurationValue
                }),
                credentials: 'include'
            });
            if (!resp.ok) {
                settingsStatus.textContent = 'Failed to save.';
                return;
            }
            const data = await resp.json();
            settingsStatus.textContent = 'Saved.';
            if (typeof data.maxUserMessageLength === 'number') {
                maxCharsInput.value = data.maxUserMessageLength;
            }
            if (typeof data.maxSessionDurationMinutes === 'number') {
                maxDurationInput.value = data.maxSessionDurationMinutes;
            }
        } catch {
            settingsStatus.textContent = 'Failed to save.';
        } finally {
            saveSettingsBtn.disabled = false;
            setTimeout(() => { settingsStatus.textContent = ''; }, 1500);
        }
    }
    
    // File upload
    fileInput.addEventListener('change', async function() {
        const file = this.files[0];
        if (!file) return;
        
        filePreviewContainer.classList.remove('d-none');
        filePreviewName.textContent = file.name;
        filePreviewSize.textContent = formatFileSize(file.size);
        
        if (file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (e) => {
                filePreviewImage.src = e.target.result;
                filePreviewImage.classList.remove('d-none');
            };
            reader.readAsDataURL(file);
        } else {
            filePreviewImage.classList.add('d-none');
        }
        
        const formData = new FormData();
        formData.append('file', file);
        
        try {
            sendButton.disabled = true;
            const response = await fetch('/api/chat/upload-file', {
                method: 'POST',
                body: formData,
                credentials: 'include'
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'Upload failed');
            }
            
            const data = await response.json();
            uploadedFilePath = data.filePath;
            uploadedFileType = data.fileType;
        } catch (err) {
            alert('File upload failed: ' + err.message);
            clearFileUpload();
        } finally {
            sendButton.disabled = !activeChatSessionId;
        }
    });
    
    removeFileBtn.addEventListener('click', clearFileUpload);
    
    function clearFileUpload() {
        fileInput.value = '';
        filePreviewContainer.classList.add('d-none');
        filePreviewImage.src = '';
        filePreviewImage.classList.add('d-none');
        uploadedFilePath = null;
        uploadedFileType = null;
    }
    
    // Voice recording functions
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    
    function updateRecordingTimer() {
        if (recordingStartTime) {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            recordingTimerEl.textContent = formatTime(elapsed);
        }
    }
    
    function stopRecordingTimer() {
        if (recordingTimer) {
            clearInterval(recordingTimer);
            recordingTimer = null;
        }
        recordingStartTime = null;
    }
    
    async function startVoiceRecording() {
        try {
            if (!activeChatSessionId) {
                alert('Please select a chat first.');
                return;
            }
            
            // Request microphone permission
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            recordingStream = stream;
            
            // Determine MIME type (prefer webm with opus codec)
            let mimeType = 'audio/webm;codecs=opus';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                mimeType = 'audio/webm';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = ''; // Use browser default
                }
            }
            
            // Create MediaRecorder
            mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
            audioChunks = [];
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
                await uploadVoiceRecording(audioBlob);
                
                // Stop all tracks
                if (recordingStream) {
                    recordingStream.getTracks().forEach(track => track.stop());
                    recordingStream = null;
                }
            };
            
            mediaRecorder.onerror = (event) => {
                console.error('MediaRecorder error:', event);
                alert('Recording error occurred. Please try again.');
                cancelVoiceRecording();
            };
            
            // Start recording
            mediaRecorder.start();
            recordingStartTime = Date.now();
            recordingTimer = setInterval(updateRecordingTimer, 1000);
            
            // Update UI
            voiceRecordBtn.classList.add('d-none');
            voiceRecordingIndicator.classList.remove('d-none');
            messageInput.disabled = true;
            sendButton.disabled = true;
            
        } catch (err) {
            console.error('Error starting recording:', err);
            if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                alert('Microphone permission denied. Please allow microphone access and try again.');
            } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                alert('No microphone found. Please connect a microphone and try again.');
            } else {
                alert('Failed to start recording: ' + err.message);
            }
        }
    }
    
    function stopVoiceRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
        }
        stopRecordingTimer();
        
        // Update UI
        voiceRecordBtn.classList.remove('d-none');
        voiceRecordingIndicator.classList.add('d-none');
        messageInput.disabled = !activeChatSessionId;
        sendButton.disabled = !activeChatSessionId;
    }
    
    function cancelVoiceRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
        }
        
        // Stop all tracks
        if (recordingStream) {
            recordingStream.getTracks().forEach(track => track.stop());
            recordingStream = null;
        }
        
        audioChunks = [];
        stopRecordingTimer();
        
        // Update UI
        voiceRecordBtn.classList.remove('d-none');
        voiceRecordingIndicator.classList.add('d-none');
        messageInput.disabled = !activeChatSessionId;
        sendButton.disabled = !activeChatSessionId;
    }
    
    async function uploadVoiceRecording(audioBlob) {
        try {
            sendButton.disabled = true;
            
            const formData = new FormData();
            // Determine file extension from MIME type
            let extension = '.webm';
            if (audioBlob.type.includes('ogg')) extension = '.ogg';
            else if (audioBlob.type.includes('mp4') || audioBlob.type.includes('m4a')) extension = '.m4a';
            else if (audioBlob.type.includes('wav')) extension = '.wav';
            
            const fileName = `recording${extension}`;
            formData.append('file', audioBlob, fileName);
            
            const response = await fetch('/api/chat/upload-voice', {
                method: 'POST',
                body: formData,
                credentials: 'include'
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'Upload failed');
            }
            
            const data = await response.json();
            
            // Send voice message via SignalR
                    await ChatClient.sendMessageTo(activeChatSessionId, data.filePath, 'Voice');
                    
                } catch (err) {
                    // Check if error is due to session not found (user may have started new session)
                    if (err.message && (err.message.includes('not found') || err.message.includes('Chat session'))) {
                        const chat = openChats[activeChatSessionId];
                        if (chat && chat.userId) {
                            try {
                                const oldSessionId = activeChatSessionId;
                                await ChatClient.leaveChat(oldSessionId);
                                
                                const response = await fetch('/api/chat/open', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ userId: chat.userId }),
                                    credentials: 'include'
                                });
                                
                                if (response.ok) {
                                    const body = await response.json();
                                    const newSessionId = body.chatSessionId;
                                    
                                    if (newSessionId && newSessionId !== oldSessionId) {
                                        const oldChat = openChats[oldSessionId];
                                        delete openChats[oldSessionId];
                                        
                                        const tabBtn = tabs.querySelector(`.chat-tab[data-chat-session-id="${oldSessionId}"]`);
                                        if (tabBtn) {
                                            tabBtn.setAttribute('data-chat-session-id', newSessionId);
                                        }
                                        
                                        if (oldChat && oldChat.panelEl) {
                                            oldChat.panelEl.setAttribute('data-chat-session-id', newSessionId);
                                            openChats[newSessionId] = { userId: chat.userId, userLabel: chat.userLabel, panelEl: oldChat.panelEl };
                                        }
                                        
                                        await ChatClient.joinChat(newSessionId);
                                        activeChatSessionId = newSessionId;
                                        setActiveChat(newSessionId);
                                        await loadChatHistory(newSessionId);
                                        
                                        // Retry sending voice message
                                        await ChatClient.sendMessageTo(newSessionId, data.filePath, 'Voice');
                                        return;
                                    }
                                }
                            } catch (refreshErr) {
                                console.error('Failed to refresh session:', refreshErr);
                            }
                        }
                    }
                    alert('Voice upload failed: ' + err.message);
                } finally {
                    sendButton.disabled = !activeChatSessionId;
                }
            }
    
    // Voice recording event listeners
    voiceRecordBtn.addEventListener('click', startVoiceRecording);
    voiceStopBtn.addEventListener('click', stopVoiceRecording);
    voiceCancelBtn.addEventListener('click', cancelVoiceRecording);
    
    // Send message
    sendButton.addEventListener('click', async function() {
        const text = messageInput.value.trim();
        if (!text && !uploadedFilePath) return;
        if (!activeChatSessionId) return;
        
        try {
            sendButton.disabled = true;
            
            if (uploadedFilePath) {
                const messageType = uploadedFileType === 'image' ? 'Image' : 'File';
                await ChatClient.sendMessageTo(activeChatSessionId, uploadedFilePath, messageType);
                clearFileUpload();
            } else {
                await ChatClient.sendMessageTo(activeChatSessionId, text);
            }
            
            messageInput.value = '';
            messageInput.style.height = 'auto';
        } catch (err) {
            // Check if error is due to session not found (user may have started new session)
            if (err.message && (err.message.includes('not found') || err.message.includes('Chat session'))) {
                const chat = openChats[activeChatSessionId];
                if (chat && chat.userId) {
                    // Refresh the session for this user
                    try {
                        const oldSessionId = activeChatSessionId;
                        await ChatClient.leaveChat(oldSessionId);
                        
                        // Get new session
                        const response = await fetch('/api/chat/open', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ userId: chat.userId }),
                            credentials: 'include'
                        });
                        
                        if (response.ok) {
                            const body = await response.json();
                            const newSessionId = body.chatSessionId;
                            
                            if (newSessionId && newSessionId !== oldSessionId) {
                                // Update openChats
                                const oldChat = openChats[oldSessionId];
                                delete openChats[oldSessionId];
                                
                                // Update tab
                                const tabBtn = tabs.querySelector(`.chat-tab[data-chat-session-id="${oldSessionId}"]`);
                                if (tabBtn) {
                                    tabBtn.setAttribute('data-chat-session-id', newSessionId);
                                }
                                
                                // Update panel
                                if (oldChat && oldChat.panelEl) {
                                    oldChat.panelEl.setAttribute('data-chat-session-id', newSessionId);
                                    openChats[newSessionId] = { userId: chat.userId, userLabel: chat.userLabel, panelEl: oldChat.panelEl };
                                }
                                
                                // Join new SignalR group
                                await ChatClient.joinChat(newSessionId);
                                
                                // Update active session
                                activeChatSessionId = newSessionId;
                                setActiveChat(newSessionId);
                                
                                // Reload history for new session
                                await loadChatHistory(newSessionId);
                                
                                // Retry sending the message
                                if (uploadedFilePath) {
                                    const messageType = uploadedFileType === 'image' ? 'Image' : 'File';
                                    await ChatClient.sendMessageTo(newSessionId, uploadedFilePath, messageType);
                                    clearFileUpload();
                                } else {
                                    await ChatClient.sendMessageTo(newSessionId, text);
                                }
                                
                                messageInput.value = '';
                                messageInput.style.height = 'auto';
                                return; // Success, exit early
                            }
                        }
                    } catch (refreshErr) {
                        console.error('Failed to refresh session:', refreshErr);
                    }
                }
            }
            alert('Failed to send: ' + err.message);
        } finally {
            sendButton.disabled = !activeChatSessionId;
        }
    });
    
    messageInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendButton.click();
        }
    });
    
    messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 120) + 'px';
    });
    
    // Initialize
    async function init() {
        await ChatClient.init(async function(message) {
            // Check if we have this session open
            if (openChats[message.chatSessionId]) {
                renderMessage(message, openChats[message.chatSessionId].panelEl);
                if (message.role !== 'Admin') {
                    if (message.chatSessionId === activeChatSessionId) {
                        await markMessagesAsSeen(message.chatSessionId);
                    } else {
                        // New message in a chat we're not viewing - increment unread badge
                        const userId = openChats[message.chatSessionId].userId || message.fromUserId;
                        if (userId) {
                            const count = (unreadByUserId[userId] || 0) + 1;
                            updateUnreadBadge(userId, count);
                        }
                    }
                }
            } else {
                // Message received for a session we don't have open - user may have started new session
                // Try to find if we have a chat open for this user (by fromUserId)
                const fromUserId = message.fromUserId;
                let matchingChat = null;
                let oldSessionId = null;
                
                for (const [sessionId, chat] of Object.entries(openChats)) {
                    if (chat.userId === fromUserId) {
                        matchingChat = chat;
                        oldSessionId = sessionId;
                        break;
                    }
                }
                
                if (matchingChat && oldSessionId !== message.chatSessionId) {
                    // User has a new session - refresh it
                    try {
                        await ChatClient.leaveChat(oldSessionId);
                        
                        const response = await fetch('/api/chat/open', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ userId: matchingChat.userId }),
                            credentials: 'include'
                        });
                        
                        if (response.ok) {
                            const body = await response.json();
                            const newSessionId = body.chatSessionId;
                            
                            if (newSessionId === message.chatSessionId) {
                                // Update openChats
                                const oldChat = openChats[oldSessionId];
                                delete openChats[oldSessionId];
                                
                                // Update tab
                                const tabBtn = tabs.querySelector(`.chat-tab[data-chat-session-id="${oldSessionId}"]`);
                                if (tabBtn) {
                                    tabBtn.setAttribute('data-chat-session-id', newSessionId);
                                }
                                
                                // Update panel
                                if (oldChat && oldChat.panelEl) {
                                    oldChat.panelEl.setAttribute('data-chat-session-id', newSessionId);
                                    openChats[newSessionId] = { userId: matchingChat.userId, userLabel: matchingChat.userLabel, panelEl: oldChat.panelEl };
                                }
                                
                                // Join new SignalR group
                                await ChatClient.joinChat(newSessionId);
                                
                                // Update active session if it was the old one
                                if (activeChatSessionId === oldSessionId) {
                                    activeChatSessionId = newSessionId;
                                    setActiveChat(newSessionId);
                                }
                                
                                // Reload history and render the message
                                await loadChatHistory(newSessionId);
                                renderMessage(message, openChats[newSessionId].panelEl);
                                if (message.role !== 'Admin' && newSessionId === activeChatSessionId) {
                                    markMessagesAsSeen(newSessionId);
                                }
                            }
                        }
                    } catch (err) {
                        console.error('Failed to refresh session on message receive:', err);
                    }
                }
            }
        });
        
        ChatClient.onPresenceChanged(function(event) {
            const dot = document.getElementById('status-' + event.userId);
            const text = document.getElementById('status-text-' + event.userId);
            if (dot) {
                const statusClass = event.status === 'Online'
                    ? 'online'
                    : (event.status === 'Idle' ? 'idle' : 'offline');
                dot.className = 'user-status-dot ' + statusClass;
            }
            if (text) {
                if (event.status === 'Online') text.textContent = 'Online';
                else if (event.status === 'Idle') text.textContent = 'Idle';
                else text.textContent = 'Last seen: ' + new Date(event.lastSeen).toLocaleString();
            }
        });
        
        ChatClient.onMessageStatusChanged(function(event) {
            if (openChats[event.chatSessionId]) {
                event.messageIds.forEach(messageId => {
                    const statusSpan = openChats[event.chatSessionId].panelEl.querySelector(`.message-status[data-message-id="${messageId}"]`);
                    if (statusSpan) {
                        const statusText = event.status || 'Sent';
                        const statusIcon = statusText === 'Seen' ? '‚úì‚úì' : '‚úì';
                        statusSpan.textContent = `${statusIcon} ${statusText}`;
                    }
                });
            }
        });
        
        await ChatClient.joinAdminPresence();
        await loadUsers();
        await loadChatSettings();
        
        if (saveSettingsBtn) saveSettingsBtn.addEventListener('click', saveChatSettings);
        
        const adminLogoutBtn = document.getElementById('adminLogoutBtn');
        const adminLogoutForm = document.getElementById('adminLogoutForm');
        if (adminLogoutBtn && adminLogoutForm) {
            adminLogoutBtn.addEventListener('click', function() {
                if (typeof ChatClient !== 'undefined' && typeof ChatClient.stop === 'function') {
                    ChatClient.stop().then(function() { adminLogoutForm.submit(); });
                } else {
                    adminLogoutForm.submit();
                }
            });
        }
        
        // Restore tabs
        const toRestore = loadOpenChatsFromStorage();
        for (const item of toRestore) {
            if (!item || !item.chatSessionId) continue;
            await openChatForUser(item.userId, item.userLabel || 'Chat', item.chatSessionId);
        }
    }
    
    document.addEventListener('DOMContentLoaded', init);
})();
    </script>
}